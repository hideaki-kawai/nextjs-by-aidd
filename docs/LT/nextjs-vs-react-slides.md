---
marp: true
theme: default
paginate: true
style: |
  section {
    font-family: 'Arial', sans-serif;
  }
  h1 {
    color: #0070f3;
    text-align:center;
  }
  h2 {
    color: #0070f3;
  }
  .presenter {
    font-size: 1.5em;
    margin-top: 2em;
    color: #333;
    font-style: italic;
    text-align: center;
  }
  .special-heading {
    color: #0070f3;
  }
---

# React と Next.js の最新開発ベストプラクティス

<div class="presenter">Hideaki Kawai</div>

---

<h1> Next.js は現在最も AI 開発の<br>フロントエンドで採用されている技術 </h1>

---

## React と Next.js の違い

- React は UI コンポーネントライブラリ
- Next.js は React フレームワークで、追加機能を提供
  - ルーティング、レンダリング、最適化など
- **現在は React 単体で利用することはほぼなく、Next.js などのフレームワークと組み合わせて使用するのが一般的**
- Next.js は React 18 の最新機能（Server Components、Suspense など）をフル活用

---

## レンダリング方法の違い

- **CSR (Client-Side Rendering)**
  - ブラウザ上で JavaScript を実行してレンダリング
  - 初期ロードが遅い、SEO に不利
  - React の基本的なレンダリング方法
- **SSR (Server-Side Rendering)**
  - サーバー上で HTML を生成し、クライアントに送信
  - 初期ロードが速い、SEO に有利
  - Next.js の主要な特徴の一つ

---

## レンダリング方法の違い（続き）

- **SSG (Static Site Generation)**
  - ビルド時に HTML を生成
  - 最も高速、CDN でキャッシュ可能
  - 動的なコンテンツには適さない
- **ISR (Incremental Static Regeneration)**
  - SSG + 定期的な再生成
  - 静的なパフォーマンスと動的なコンテンツのバランス

---

## Next.js の CC と SC

- **クライアントコンポーネント (CC)**
  - `"use client"` ディレクティブを使用
  - インタラクティブな機能を実装可能
  - useState、useEffect などの React フックが使用可能
  - クライアントサイドで実行される
- **サーバーコンポーネント (SC)**
  - デフォルトで全てのコンポーネントはサーバーコンポーネント
  - サーバーサイドで実行され、HTML として送信
  - データベースやファイルシステムに直接アクセス可能
  - JavaScript バンドルサイズを削減

---

## Next.js の CC と SC の構造

```
アプリケーション
├── サーバーコンポーネント (SC)
│   ├── データフェッチ
│   ├── ページレイアウト
│   └── 静的コンテンツ
│       └── クライアントコンポーネント (CC)
│           ├── インタラクティブ要素
│           └── ユーザーイベント処理
└── レンダリングプロセス
    ├── SC: サーバーでレンダリング
    └── CC: クライアントでハイドレーション
```

---

## Cursor の動作について

- Cursor では何も指示しないと基本的に**クライアントコンポーネントを生成する傾向**がある
- 多くの場合 `"use client"` ディレクティブを自動的に追加
- クライアントコンポーネントを作成する際に API ルート (`app/api/xxx`) も生成しようとする
- このデフォルト動作は必ずしも最適ではない

---

## サーバーアクションのメリット

- 秘匿情報（API キーなど）をクライアントに露出させない
- サーバーサイドで処理を行うためパフォーマンスが向上
- データベースへの直接アクセスが可能
- クライアントへの JavaScript 送信量を削減
- Next.js 13.4 以降で正式サポート

---

## ベストプラクティス（1）

### 開発には統一感を持たせる

- プロジェクト全体でコンポーネント設計の一貫性を保つ
- チーム内でルールを明確にする

### アプローチの選択肢

- **全てクライアントコンポーネントで統一**
  - シンプルで理解しやすい
  - ただし大量のデータフェッチはクライアント側の負荷が高く、パフォーマンスが低下する可能性

---

## ベストプラクティス（2）

### 責務を分ける（推奨）

- データフェッチはサーバーコンポーネント
- リアクティブな挙動はクライアントコンポーネント
- コンポーネントの役割が明確になり保守性が向上

### チーム開発での統一

- 実装者によるばらつきを防ぐ
- `.cursorrules` または notepads を使用してチーム間で統一ルールを共有
- コードレビューでコンポーネントの種類を確認する習慣をつける

---

## まとめ

- Next.js は React の機能を拡張し、モダンなウェブ開発に最適化
- サーバーコンポーネントとクライアントコンポーネントを適切に使い分けることが重要
- チーム開発では統一されたアプローチを採用する
- 最新の Next.js の機能（App Router、サーバーアクション）を積極的に活用する
- 責務の分離により保守性とパフォーマンスを向上させる
